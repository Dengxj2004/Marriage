# ORCID女性姓名变化检测程序

## 核心逻辑

### 性别筛选
- 使用`gender-guesser`库识别性别
- 仅保留`female` + `mostly_female`

### 姓名变化检测
**变化模式**:
1. 完全随夫姓：Jane Smith Jones → Jane Miller
2. 保留娘家姓作中间名：Jane Smith Jones → Jane Jones Miller Jane Smith → Jane Smith Johnson
3. 保留自己中间名：Jane Smith Jones → Jane Smith Miller
4. 使用连字符：Jane Smith Jones → Jane Jones - Miller

**关键判断条件**:
- 包含原姓氏或名字
- 名字部分相同 (同一人确认)  
- 时间先后顺序合理
- 排除缩写情况 (`J. Smith`)

### 输出格式
```csv
port_name,id,s_name,first_date,o_name,last_modified_date,gender
```

## 算法细节

### XML解析流程
1. 提取`person:name`基本信息
2. 获取`other-name:other-name`变更信息  
3. 提取时间戳进行比对
4. 性别识别过滤

### 姓名匹配逻辑
1. **预处理**: 小写化 + 去标点 + 空格标准化
2. **关联性**: 检查姓氏/名字包含关系
3. **时间序**: 确保修改时间合理性
4. **模式识别**: 
   - 有共同姓氏 → 加中间名检测
   - 无共同姓氏 → 改姓检测
   - 排除缩写 → 避免误判

## 2025-08-13修改

### 数据提取逻辑
- 改用`person:name`的`given-names` + `family-name`作为基准姓名，不使用`source-name`
- 支持处理多个`other-name:other-name`标签
- 提取`created-date`而非`last-modified-date`进行时间比较
- 引入 Levenshtein 距离算法，替换原有的严格相等（==）判断，以实现对姓名拼写错误的容错处理。


### 时间判断条件
- 时间差要求从"日期不同"改为"相差30天以上"

### 姓名变化检测优化
- 修正加中间名误判：检查最后一个姓氏是否改变
- `anna smith` → `anna adam smith`不再被识别为姓氏变化
- `anna smith` → `anna adam johnson`正确识别为改姓


## 2025-08-18 修改

### 问题根源分析：为什么会出现 RecursionError
这个错误的核心原因在子进程试图将处理结果返回给主进程时发生的。

- 多进程通信机制：当使用 concurrent.futures.ProcessPoolExecutor 时，每个子进程都在自己独立的内存空间中运行。当一个子进程完成了任务（即 process_file_chunk 函数执行完毕），它需要把返回值（results, processed, len(results), error_count）发送回主进程。
- Pickling（序列化）：为了跨进程发送数据，Python 使用一个叫做 pickle 的模块来将对象“序列化”（或称为“打包”）。它将复杂的Python对象（如列表、字典）转换成一个字节流，以便在进程间传输。主进程接收到这个字节流后再“反序列化”，还原成原始的Python对象。
- BeautifulSoup 对象的问题：当使用 BeautifulSoup 解析XML后，通过 .string 获取到的内容，例如 given_names_tag.string，它返回的不是一个纯粹的 Python str 类型，而是一个 bs4.element.NavigableString 对象。
- 罪魁祸首：这个 NavigableString 对象虽然行为上很像字符串，但它内部仍然保留着对整个 BeautifulSoup 解析树的引用（比如它的父节点、兄弟节点等）。整个解析树是一个巨大且复杂的对象，常常包含循环引用，并且是**不可序列化（unpicklable）**的。
- 错误发生：当子进程试图将包含 NavigableString 对象的 results 列表序列化时，pickle 模块会尝试跟随这些引用去序列化整个 BeautifulSoup 解析树。由于树的复杂性和可能的循环引用，这个过程陷入了无限递归，最终导致 RecursionError: maximum recursion depth exceeded while pickling an object。
- traceback 明确地指出了这一点：File "/usr/local/miniconda3/lib/python3.10/multiprocessing/reduction.py", line 51, in dumps cls(buf, protocol).dump(obj) RecursionError: maximum recursion depth exceeded while pickling an object

### 解决方案

**1. 针对问题XML文件的健壮性错误处理**

*   **解决方案:** 当任何文件导致解析失败时（如XML格式错误、递归超限、内存不足等），程序现在会：
    1.  通过 `try...except` 块安全地捕获异常。
    2.  自动将该问题文件**复制**到一个专用的 `problem_xml_files` 目录中。
    3.  根据错误类型（如 `parse_error`, `large_files` 等）将其归类到不同的子文件夹，便于后续排查。

**2. 解决多进程中的 `Pickling RecursionError` 错误**

*   **解决方案:** 在将从 BeautifulSoup 提取的任何文本放入返回结果之前，必须将其显式转换为纯 Python 字符串 str。使用 tag.get_text(strip=True) 来代替 .string。get_text() 总是返回一个标准的 str 对象，并且可以处理更复杂的情况（例如标签内有多个文本节点）。


